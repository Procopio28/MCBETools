(function(){
  var JSZIP_CDN = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
  function loadJSZip(){
    return new Promise(function(resolve,reject){
      if(window.JSZip) return resolve(window.JSZip);
      var s = document.createElement('script');
      s.src = JSZIP_CDN;
      s.onload = function(){ resolve(window.JSZip); };
      s.onerror = function(){ reject(new Error('Failed to load JSZip')); };
      document.head.appendChild(s);
    });
  }
  function uuidv4(){
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,function(c){
      var r = Math.random()*16|0, v = c==='x'? r : (r&0x3|0x8);
      return v.toString(16);
    });
  }
  var currentSkin = { url: null, username: 'skin' };
  function extractNameFromUrl(url){
    try{
      var parts = url.split('/');
      return (parts[parts.length-1].split('.')[0]) || 'skin';
    }catch(e){ return 'skin'; }
  }
  function createButtonsFor(img){
    if(!img || document.getElementById('mcpack-download-wrapper')) return;
    var wrapper = document.createElement('div');
    wrapper.id = 'mcpack-download-wrapper';
    wrapper.style.marginTop = '8px';
    var pngBtn = document.createElement('button');
    pngBtn.id = 'mcpack-download-png';
    pngBtn.textContent = 'Download PNG';
    var packBtn = document.createElement('button');
    packBtn.id = 'mcpack-download-mcpack';
    packBtn.textContent = 'Download MCPACK';
    wrapper.appendChild(pngBtn);
    wrapper.appendChild(packBtn);
    img.insertAdjacentElement('afterend', wrapper);
    pngBtn.addEventListener('click', downloadPNG);
    packBtn.addEventListener('click', downloadMCPack);
    currentSkin.url = img.src;
    if(img.dataset && img.dataset.username) currentSkin.username = img.dataset.username;
    else currentSkin.username = extractNameFromUrl(img.src);
  }
  async function downloadPNG(){
    if(!currentSkin.url){ alert('No skin found to download'); return; }
    try{
      var res = await fetch(currentSkin.url);
      if(!res.ok){ alert('Failed to fetch skin PNG'); return; }
      var blob = await res.blob();
      var a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (currentSkin.username || 'skin') + '.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }catch(e){ alert('Error downloading PNG'); }
  }
  async function detectGeometryFromBlob(blob){
    try{
      var imgBitmap = await createImageBitmap(blob);
      var w = imgBitmap.width, h = imgBitmap.height;
      var canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(imgBitmap,0,0);
      if(h === 32) return 'geometry.humanoid.custom';
      if(w === 64 && h === 64){
        try{
          var d = ctx.getImageData(54,20,1,1).data;
          if(d[3] === 0) return 'geometry.humanoid.customSlim';
        }catch(e){ return 'geometry.humanoid.custom'; }
      }
      return 'geometry.humanoid.custom';
    }catch(e){
      return 'geometry.humanoid.custom';
    }
  }
  async function downloadMCPack(){
    if(!currentSkin.url){ alert('No skin found to pack'); return; }
    var zipLib;
    try{ zipLib = await loadJSZip(); } catch(e){ alert('Could not load zip library'); return; }
    try{
      var res = await fetch(currentSkin.url);
      if(!res.ok){ alert('Failed to fetch skin PNG'); return; }
      var blob = await res.blob();
      var geometry = await detectGeometryFromBlob(blob);
      var packName = 'MCBE Skin - ' + (currentSkin.username || 'Skin');
      var serialize = 'MCBE_Skin_' + (currentSkin.username || 'skin').replace(/[^\w]/g,'_');
      var skinFilename = (currentSkin.username || 'skin').replace(/[^\w]/g,'_') + '.png';
      var headerUUID = uuidv4();
      var moduleUUID = uuidv4();
      var manifest = {
        format_version: 1,
        header: {
          name: packName,
          description: 'Generated by MCBE Tools Skin Finder',
          uuid: headerUUID,
          version: [1,0,0],
          min_engine_version: [1,16,0]
        },
        modules: [
          { type: 'skin_pack', uuid: moduleUUID, version: [1,0,0] }
        ]
      };
      var skinsJson = {
        serialize_name: serialize,
        localization_name: serialize,
        skins: [
          {
            localization_name: (currentSkin.username || 'skin'),
            geometry: geometry,
            texture: skinFilename,
            type: 'free'
          }
        ]
      };
      var lang = 'skinpack.' + serialize + '=' + packName + '\n' + 'skin.' + serialize + '.' + (currentSkin.username || 'skin') + '=' + (currentSkin.username || 'Skin');
      var zip = new zipLib();
      zip.file('manifest.json', JSON.stringify(manifest, null, 2));
      zip.file('skins.json', JSON.stringify(skinsJson, null, 2));
      zip.folder('texts').file('en_US.lang', lang);
      zip.file(skinFilename, blob);
      var blobZip = await zip.generateAsync({type:'blob'});
      var a = document.createElement('a');
      a.href = URL.createObjectURL(blobZip);
      a.download = packName + '.mcpack';
      document.body.appendChild(a);
      a.click();
      a.remove();
    }catch(e){ alert('Error generating MCPACK'); }
  }
  function findExistingSkinImage(){
    var imgs = Array.from(document.querySelectorAll('img'));
    for(var i=0;i<imgs.length;i++){
      var img = imgs[i];
      if(!img.src) continue;
      if(img.src.includes('textures.minecraft.net') || img.src.toLowerCase().includes('/skin') || /avatar|skin|texture/i.test((img.alt||'') + (img.className||'') + (img.id||''))){
        return img;
      }
    }
    return null;
  }
  function observeForSkins(){
    var existing = findExistingSkinImage();
    if(existing) createButtonsFor(existing);
    var mo = new MutationObserver(function(muts){
      for(var mi=0; mi<muts.length; mi++){
        var add = muts[mi].addedNodes;
        for(var ni=0; ni<add.length; ni++){
          var node = add[ni];
          if(node.nodeType===1){
            if(node.tagName === 'IMG' && node.src && (node.src.includes('textures.minecraft.net') || node.src.toLowerCase().includes('/skin'))){
              createButtonsFor(node);
              return;
            }
            try{
              var imgs = node.querySelectorAll && node.querySelectorAll('img');
              if(imgs && imgs.length){
                for(var j=0;j<imgs.length;j++){
                  var ii = imgs[j];
                  if(ii.src && (ii.src.includes('textures.minecraft.net') || ii.src.toLowerCase().includes('/skin'))){
                    createButtonsFor(ii);
                    return;
                  }
                }
              }
            }catch(e){}
          }
        }
      }
    });
    mo.observe(document.body, { childList: true, subtree: true });
  }
  function moveShowDetailsUnderModel(){
    var all = Array.from(document.querySelectorAll('button,a'));
    var btn = all.find(function(el){
      return el.textContent && /show/i.test(el.textContent) && /detail/i.test(el.textContent);
    });
    if(!btn) return;
    var model = document.querySelector('canvas') || document.querySelector('.model') || document.querySelector('.viewer') || document.querySelector('#skin3d') || document.querySelector('.skin-viewer');
    if(!model) return;
    if(model.parentNode) model.parentNode.insertBefore(btn, model.nextSibling);
  }
  document.addEventListener('DOMContentLoaded', function(){
    observeForSkins();
    moveShowDetailsUnderModel();
    setTimeout(moveShowDetailsUnderModel, 1000);
  });
})();